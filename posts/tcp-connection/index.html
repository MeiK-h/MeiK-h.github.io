<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>MeiK&#39;s blog  | TCP 的三次握手与四次挥手</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="TCP 的三次握手与四次挥手" />
<meta property="og:description" content="TCP 协议提供了可靠的传输，但是网络是不可靠的，TCP 也无法保证数据一定会被对方接收，这是不可能做到的。TCP 实际提供的是数据的可靠递送或故障的可靠通知。

建立一个 TCP 连接需要进行三次握手，而终止一个 TCP 连接需要进行四次挥手。这篇博客就介绍一下关于 TCP 的三次握手与四次挥手与其他一些信息吧。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://meik2333.com/posts/tcp-connection/" />
<meta property="article:published_time" content="2018-08-17T20:48:23+00:00" />
<meta property="article:modified_time" content="2018-08-17T20:48:23+00:00" />
<meta itemprop="name" content="TCP 的三次握手与四次挥手">
<meta itemprop="description" content="TCP 协议提供了可靠的传输，但是网络是不可靠的，TCP 也无法保证数据一定会被对方接收，这是不可能做到的。TCP 实际提供的是数据的可靠递送或故障的可靠通知。

建立一个 TCP 连接需要进行三次握手，而终止一个 TCP 连接需要进行四次挥手。这篇博客就介绍一下关于 TCP 的三次握手与四次挥手与其他一些信息吧。">


<meta itemprop="datePublished" content="2018-08-17T20:48:23&#43;00:00" />
<meta itemprop="dateModified" content="2018-08-17T20:48:23&#43;00:00" />
<meta itemprop="wordCount" content="238">



<meta itemprop="keywords" content="网络编程,TCP,UNPv1," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TCP 的三次握手与四次挥手"/>
<meta name="twitter:description" content="TCP 协议提供了可靠的传输，但是网络是不可靠的，TCP 也无法保证数据一定会被对方接收，这是不可能做到的。TCP 实际提供的是数据的可靠递送或故障的可靠通知。

建立一个 TCP 连接需要进行三次握手，而终止一个 TCP 连接需要进行四次挥手。这篇博客就介绍一下关于 TCP 的三次握手与四次挥手与其他一些信息吧。"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://meik2333.com" class="f3 fw2 hover-white no-underline white-90 dib">
      MeiK&#39;s blog
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">TCP 的三次握手与四次挥手</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2018-08-17T20:48:23Z">August 17, 2018</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>TCP 协议提供了可靠的传输，但是网络是不可靠的，TCP 也无法保证数据一定会被对方接收，这是不可能做到的。TCP 实际提供的是数据的可靠递送或故障的可靠通知。</p>

<p>建立一个 TCP 连接需要进行三次握手，而终止一个 TCP 连接需要进行四次挥手。这篇博客就介绍一下关于 TCP 的三次握手与四次挥手与其他一些信息吧。</p>

<h2 id="三次握手">三次握手</h2>

<p>建立一个 TCP 连接时会发生下列情形。</p>

<ol>
<li>服务器必须准备好接收外来的连接。称之为<strong>被动打开</strong>（passive open）。在 Linux 上，一般是通过调用 <code>socket</code>、<code>bind</code> 和 <code>listen</code> 这三个函数来完成的。可以参照 <a href="/2018/06/29/Tinyhttpd-源码及分析/">Tinyhttpd</a> 的实现。</li>
<li>客户端通过调用 <code>connect</code> 函数发起<strong>主动打开</strong>（active open）。客户端将向服务器发送一个 SYN（同步）分节，它告诉服务器客户端将在（待建立的）连接中发送的数据的初始序列号。SYN 分节通常不携带数据，其 IP 数据报只含有一个 IP 首部、一个 TCP 首部以及可能有的 TCP 选项。</li>
<li>服务器必须确认（ACK）客户端的 SYN，同时自己也要发送一个 SYN 分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节中发送 SYN 和对客户 SYN 的 ACK（确认）。</li>
<li>客户端必须确认（ACK）服务器的的 SYN。</li>
</ol>

<p>因为这个过程中最少需要三个分组，因此称之为 TCP 的<strong>三路握手</strong>（three-way handshake）。虽然很多地方将其翻译为了三次握手，但其实际只有一次握手（不过分为了三步），如下图。</p>

<p><img src="/images/tcp-connection/TCP三次握手.png" alt="TCP 的三次握手" /></p>

<p>图中客户端的初始序列号为 J，服务器的初始序列号为 K。ACK 中的确认号是发送这个 ACK 的一端所期待的下一个序列号（即接收到的 SYN + 1）。</p>

<h3 id="建立连接涉及到的函数">建立连接涉及到的函数</h3>

<ul>
<li><code>socket</code>：创建一个套接字，用于建立 TCP 连接（客户端）或者监听端口（服务器）</li>
<li><code>bind</code>：服务器使用，绑定套接字与端口</li>
<li><code>listen</code>：服务器使用，开始监听端口</li>
<li><code>connect</code>：客户端使用，尝试建立一个到指定服务器的连接</li>
<li><code>accept</code>：服务器使用，接收连接并响应，可以获得一个三次握手完成后的连接</li>
</ul>

<h3 id="tcp-选项">TCP 选项</h3>

<p>每一个 SYN 可以含有多个 TCP 选项。下面是常用的TCP 选项。</p>

<ul>
<li>MSS 选项。发送 SYN 的 TCP 一端使用本选项通告对端它的<strong>最大分节大小</strong>（maximum segment size），即 MSS。也就是它在本连接的每个 TCP 分节中愿意接受的最大数据量。发送端 TCP 使用接收端的 MSS 作为所发送分节的最大大小。</li>
<li>窗口规模选项。TCP 首部表示窗口大小的字段占 16 位，因此最大只能表示 65535。为了适应当今普及的高速网络连接，这个字段指定了窗口大小需要左移的位数（0~14），可以提供最大接近 1GB（65535 * 2^14)的窗口大小。</li>
<li>时间戳选项。用以防止重复的失而复得的分组对数据造成破坏。</li>
</ul>

<h3 id="为什么是三次握手而不是两次或者四次">为什么是三次握手而不是两次或者四次</h3>

<p>关于这个问题，我在网上也看了不少回答。知乎上有<a href="https://www.zhihu.com/question/24853633">一个问题</a>就是对这个的讨论，里面有很多答主回答的都很不错。</p>

<p>我自己对这个问题的理解是这个样子的：三次握手中的第二次，在一个分节中同时递送了对客户端的确认（ACK）和自己的 SYN，而如果将这个分节拆开来看的话，就是客户端和服务器都分别发送了一个 SYN 分节和对其的 ACK。</p>

<p>网络环境是不能确定可靠的，三次握手后，客户端仍然不知道服务器有没有接收到自己最后一个 ACK。但这两个 SYN 和 ACK 可以测试双方的发送与接收能力，即使有再多的握手次数也不过是重复罢了。而这四个分节少了一个就无法测试到所有情况了。因此三次握手（两个 SYN 与两个 ACK）是最为合理的方式。</p>

<h2 id="四次挥手">四次挥手</h2>

<p>在 Linux 上，终止一个 TCP 连接有四步。</p>

<ol>
<li>某个应用程序调用 <code>close</code>，我们称该端执行<strong>主动关闭</strong>（active close）。该端的 TCP 将会发送一个 FIN 分节，表示数据发送结束。</li>
<li>接收到 FIN 分节的对端执行<strong>被动关闭</strong>（passive close）。这个 FIN 由 TCP 确认。它的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程（放在已排队等候该应用进程接收的任何其他数据之后），因为 FIN 的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</li>
<li>一段时间后，接收到这个文件描述符的应用进程将调用 <code>close</code> 关闭它的套接字。这导致它的 TCP 也发送一个 FIN。</li>
<li>接收这个最终 FIN 的原发送端 TCP（即执行主动关闭的那一端）确认这个 FIN。</li>
</ol>

<p><img src="/images/tcp-connection/TCP四次挥手.png" alt="TCP四次挥手" /></p>

<p>这个过程通常需要四个分节，在某些情况下步骤一的 FIN 会随着数据一起发送；另外，步骤二与步骤三的分节有可能被合并为一个分节。</p>

<h3 id="为什么是四次挥手">为什么是四次挥手</h3>

<p>挥手时双方需要明确的通知到对方连接已经结束了，因此双方各自发送一个结束的信号与对结束信号的确认。</p>

<h3 id="time-wait-状态">TIME_WAIT 状态</h3>

<p>在关闭一个 TCP 连接的过程中，执行主动关闭的一端需要维持一个长达 2MSL 的 TIME_WAIT 状态。</p>

<p>MSL 全称为 maximum segment lifetime，即最长分节生命期。RFC 1122 [Braden 1989] 的建议值为 2 分钟，而源自 Berkeley 的实现传统上使用 30 秒这个值。虽然 IP 数据报在网络中存活的限制是跳限（hop limit）而非时间，但是一般认为，一个 IP 数据报在网络中不能存活超过 MSL。基于这个前提，设立了时长为 2MSL 的 TIME_WAIT 状态。</p>

<p>TIME_WAIT 状态有两个存在的理由：</p>

<ol>
<li>可靠地实现 TCP 全双工连接的终止；</li>
<li>允许老的重复分节在网络中消逝。</li>
</ol>

<p>假设在终止 TCP 连接时，最后一个 ACK 分节丢失了，那么被动关闭的一方（在图中为服务器）将重发第三步的 FIN N，如果客户端已经清理了 TCP 连接的信息，那么将无法重发最后的 ACK。因此主动关闭的一方需要保持 TIME_WAIT 状态。</p>

<p>对于第二个理由，假设两台电脑在进行 TCP 连接的时候发生了路由异常，某个分组没有被及时送达。两台电脑通过重传恢复了连接，并正常终止了这个 TCP 连接。紧接着，在同样的 IP 和同样的端口，这两台电脑又开始了一次新的 TCP 连接，此时之前没有及时送达的分组姗姗来迟，就有可能被误认为是新的连接的分节。为了解决这个问题，同样需要保持 TIME_WAIT 状态。这也解答了 TIME_WAIT 状态为什么是 2MSL：因为在一个 IP 最长生存时间不会超过 MSL 的前提下， 2MSL 时间可以保证每个方向的分组都已经在网络中消逝了。</p>

<h2 id="参考">参考</h2>

<ul>
<li>UNPv1</li>
<li><a href="https://www.zhihu.com/question/24853633">TCP 为什么是三次握手，而不是两次或四次？</a> - 知乎问题</li>
</ul>

<h2 id="工具">工具</h2>

<ul>
<li><a href="https://www.draw.io/">draw.io</a>，在线作图工具</li>
</ul><ul class="pa0">
  
   <li class="list">
     <a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">网络编程</a>
   </li>
  
   <li class="list">
     <a href="/tags/tcp" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">TCP</a>
   </li>
  
   <li class="list">
     <a href="/tags/unpv1" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">UNPv1</a>
   </li>
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/posts/study-curl/">curl 学习</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/webbench-source-and-analysis/">WebBench 源码分析 [不推荐阅读]</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/tinyhttpd-source-and-analysis/">Tinyhttpd 源码及分析</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://meik2333.com" >
    &copy; 2019 MeiK&#39;s blog
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
